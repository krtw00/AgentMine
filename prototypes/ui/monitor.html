<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>AgentMine UI Prototype - Monitor (Run list)</title>
    <link rel="stylesheet" href="./style.css" />
  </head>
  <body>
    <div class="app">
      <div class="topbar">
        <div class="brand">AgentMine</div>
        <div class="pill"><span class="muted">Project</span> <strong>AgentMine</strong></div>
        <div class="pill"><span class="muted">SSE</span> <strong id="sseState">connected</strong></div>
        <div class="spacer"></div>
        <a class="btn" href="./monitor-split.html">Monitor B（Split）</a>
        <a class="btn" href="./monitor-graph.html">Monitor C（Graph）</a>
        <a class="btn" href="./settings.html">Settings</a>
        <a class="btn" href="./agents.html">Agent Profiles</a>
      </div>

      <div class="main">
        <div class="left">
          <div class="section">
            <h2>Monitor A（Outline table）</h2>
            <div class="row">
              <input
                class="search"
                id="search"
                placeholder="検索: task / run / reason / agent_profile"
                autocomplete="off"
              />
              <label class="toggle">
                <input type="checkbox" id="groupByTask" checked />
                Group by task tree（既定）
              </label>
              <button class="btn primary" id="btnNewTask">+ Task</button>
            </div>
            <div class="row" style="margin-top: 8px">
              <span class="pill"><span class="muted">Filter</span> <strong>running</strong></span>
              <span class="pill"><span class="muted">Filter</span> <strong>needs_review</strong></span>
              <span class="pill"><span class="muted">Filter</span> <strong>dod_failed</strong></span>
              <span class="pill"><span class="muted">Hint</span> <strong>click row</strong></span>
            </div>
          </div>

          <div class="tableWrap">
            <table>
              <thead>
                <tr>
                  <th style="width: 100px">Status</th>
                  <th style="width: 260px">Task</th>
                  <th style="width: 260px">Reasons</th>
                  <th style="width: 160px">Agent</th>
                  <th style="width: 110px">Started</th>
                  <th style="width: 90px">Duration</th>
                  <th style="width: 90px">DoD</th>
                  <th style="width: 90px">Violations</th>
                  <th class="waterfall">Waterfall</th>
                </tr>
              </thead>
              <tbody id="rows"></tbody>
            </table>
          </div>
        </div>

        <div class="right">
          <div class="section">
            <h2>Details</h2>
            <div class="row">
              <span class="pill"><span class="muted">Selected</span> <strong id="selLabel">none</strong></span>
              <span class="pill"
                ><span class="muted">head_sha</span> <strong class="mono" id="selSha">-</strong></span
              >
            </div>
          </div>

          <div class="tabs" id="tabs"></div>
          <div class="panel" id="panel"></div>
        </div>
      </div>
    </div>

    <!-- Task drawer -->
    <div class="drawerBackdrop" id="drawerBackdrop"></div>
    <div class="drawer" id="drawer">
      <div class="drawerHeader">
        <div class="drawerTitle">Create Task</div>
        <div class="spacer"></div>
        <button class="btn" id="btnCloseDrawer">Close</button>
      </div>
      <div class="drawerBody">
        <div class="field">
          <label class="label">Title（必須）</label>
          <input class="input" value="Implement Monitor UI" />
        </div>
        <div class="field">
          <label class="label">Description</label>
          <textarea class="textarea">MonitorをRun一覧（Network風）で実装する。</textarea>
        </div>

	        <div class="field">
	          <label class="label">write_scope（必須）</label>
	          <div class="hint">B（ファイルツリー選択）で確定である。</div>
	          <div class="hint">
	            個人情報/秘密情報をAIから隠す場合は、write_scopeではなくexcludeを設定する。
	            <a href="./settings.html" target="_blank" rel="noopener">Settings（scope.defaultExclude）</a> を参照。
	          </div>
	        </div>

	        <div class="field">
	          <label class="label">Tree selection（B）</label>
	          <div class="tree" id="tree">
	            <ul>
	              <li>
	                <label><input type="checkbox" data-glob="apps/web/**" checked /> apps/web/</label>
              </li>
              <li>
                <label><input type="checkbox" data-glob="apps/daemon/**" /> apps/daemon/</label>
              </li>
              <li>
                <label><input type="checkbox" data-glob="packages/**" checked /> packages/</label>
                <ul>
                  <li>
                    <label><input type="checkbox" data-glob="packages/core/**" /> packages/core/</label>
                  </li>
                  <li>
                    <label><input type="checkbox" data-glob="packages/ui/**" /> packages/ui/</label>
                  </li>
                </ul>
              </li>
              <li>
                <label><input type="checkbox" data-glob="docs/**" checked /> docs/</label>
              </li>
	            </ul>
	          </div>
	          <div class="hint">視覚的で安全。ファイルツリーの取得と表現が必要。</div>
	        </div>

        <div class="field">
          <label class="label">プレビュー（最終write_scope）</label>
          <div class="chips" id="scopePreview"></div>
          <div class="hint">
            実装では、この結果をTask.write_scopeとして保存する。run開始時はscope_snapshotに固定される。
          </div>
        </div>
      </div>
      <div class="drawerFooter">
        <button class="btn">Cancel</button>
        <button class="btn primary">Create</button>
      </div>
    </div>

    <script>
      const data = [
        {
          taskId: 10,
          taskTitle: "MVP UI",
          runs: [],
          children: [
            {
              taskId: 12,
              taskTitle: "Monitor UI (Run-first Network)",
              runs: [],
              children: [
                {
                  taskId: 121,
                  taskTitle: "Run table + filters",
                  runs: [
                    {
                      runId: 41,
                      status: "running",
                      reasons: ["merge_pending"],
                      agent: "coder",
                      started: "12:41",
                      durationSec: 132,
                      dod: "pending",
                      violations: 0,
                      headSha: "3f09a1b",
                    },
                    {
                      runId: 40,
                      status: "failed",
                      reasons: ["dod_failed"],
                      agent: "coder",
                      started: "12:10",
                      durationSec: 488,
                      dod: "failed",
                      violations: 0,
                      headSha: "1e2c9d4",
                    },
                  ],
                },
                {
                  taskId: 122,
                  taskTitle: "Details tabs + logs",
                  runs: [
                    {
                      runId: 43,
                      status: "completed",
                      reasons: ["merge_pending"],
                      agent: "coder",
                      started: "12:30",
                      durationSec: 210,
                      dod: "passed",
                      violations: 0,
                      headSha: "4aa91c0",
                    },
                  ],
                },
              ],
            },
            {
              taskId: 15,
              taskTitle: "Settings (exclude) UI",
              runs: [
                {
                  runId: 42,
                  status: "completed",
                  reasons: ["merge_pending"],
                  agent: "writer",
                  started: "12:50",
                  durationSec: 180,
                  dod: "passed",
                  violations: 0,
                  headSha: "7ab1c2d",
                },
              ],
            },
          ],
        },
        {
          taskId: 11,
          taskTitle: "Safety & Quality",
          runs: [],
          children: [
            {
              taskId: 13,
              taskTitle: "Fix scope violation handling",
              runs: [
                {
                  runId: 39,
                  status: "completed",
                  reasons: ["scope_violation_pending"],
                  agent: "generalist",
                  started: "11:22",
                  durationSec: 301,
                  dod: "passed",
                  violations: 2,
                  headSha: "9ad0b2c",
                },
              ],
            },
            {
              taskId: 14,
              taskTitle: "Define DoD checks",
              runs: [],
            },
          ],
        },
      ];

      const elRows = document.getElementById("rows");
      const elGroupBy = document.getElementById("groupByTask");
      const elSearch = document.getElementById("search");

      const collapsedTasks = new Set();

      function walkTasks(tasks, fn) {
        for (const t of tasks) {
          fn(t);
          for (const c of t.children ?? []) walkTasks([c], fn);
        }
      }

      function collectAllRuns(tasks) {
        const runs = [];
        walkTasks(tasks, (t) => runs.push(...(t.runs ?? [])));
        return runs;
      }

      const maxDuration = Math.max(...collectAllRuns(data).map((r) => r.durationSec), 1);

      function indentPad(depth) {
        return `<span style="display:inline-block;width:${depth * 14}px"></span>`;
      }

      function countRuns(task) {
        let n = (task.runs ?? []).length;
        for (const c of task.children ?? []) n += countRuns(c);
        return n;
      }

      function countSubtasks(task) {
        let n = 0;
        for (const c of task.children ?? []) n += 1 + countSubtasks(c);
        return n;
      }

      function badgeStatus(status) {
        if (status === "running") return '<span class="badge warn">running</span>';
        if (status === "failed") return '<span class="badge danger">failed</span>';
        if (status === "completed") return '<span class="badge ok">completed</span>';
        return `<span class="badge">${status}</span>`;
      }

      function badgeDoD(dod) {
        if (dod === "passed") return '<span class="badge ok">passed</span>';
        if (dod === "failed") return '<span class="badge danger">failed</span>';
        return '<span class="badge warn">pending</span>';
      }

      function render() {
        const q = elSearch.value.trim().toLowerCase();
        const group = elGroupBy.checked;
        elRows.innerHTML = "";

        const matches = (text) => text.toLowerCase().includes(q);
        const taskMatches = (t) => {
          if (!q) return true;
          return matches(t.taskTitle) || matches(String(t.taskId));
        };
        const runMatches = (t, r) => {
          if (!q) return true;
          return (
            matches(String(r.runId)) ||
            matches(r.status) ||
            matches(r.agent) ||
            (r.reasons ?? []).some((x) => matches(x)) ||
            matches(r.dod) ||
            matches(r.headSha) ||
            taskMatches(t)
          );
        };

        const nodeMatches = (t) => {
          if (!q) return true;
          if (taskMatches(t)) return true;
          for (const r of t.runs ?? []) if (runMatches(t, r)) return true;
          for (const c of t.children ?? []) if (nodeMatches(c)) return true;
          return false;
        };

        function taskGroupRow(task, depth) {
          const hasChildren = (task.children ?? []).length > 0 || (task.runs ?? []).length > 0;
          const isLeaf = !hasChildren;
          const isCollapsed = collapsedTasks.has(task.taskId);
          const twisty = isLeaf ? "•" : isCollapsed ? "▸" : "▾";
          const runCount = countRuns(task);
          const subtaskCount = countSubtasks(task);

          const trG = document.createElement("tr");
          trG.className = "groupRow";
          trG.dataset.kind = "task";
          trG.dataset.taskId = String(task.taskId);
          trG.innerHTML = `<td colspan="9">${indentPad(depth)}<span class="twisty">${twisty}</span> Task #${
            task.taskId
          }: ${task.taskTitle} <span class="muted">(${runCount} runs${
            subtaskCount > 0 ? `, ${subtaskCount} subtasks` : ""
          })</span></td>`;

          if (!isLeaf) {
            trG.addEventListener("click", () => {
              if (collapsedTasks.has(task.taskId)) collapsedTasks.delete(task.taskId);
              else collapsedTasks.add(task.taskId);
              render();
            });
          }

          return trG;
        }

        function emptyTaskRow(task, depth) {
          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td class="muted">-</td>
            <td>${indentPad(depth)}<span class="muted">(no runs)</span></td>
            <td class="muted">open</td>
            <td class="muted">-</td>
            <td class="muted">-</td>
            <td class="muted">-</td>
            <td class="muted">pending</td>
            <td class="muted">0</td>
            <td class="waterfall"><div class="bar"><span style="width:0%"></span></div></td>
          `;
          return tr;
        }

        function renderTaskNode(task, depth) {
          if (!nodeMatches(task)) return;

          elRows.appendChild(taskGroupRow(task, depth));

          const hasChildren = (task.children ?? []).length > 0 || (task.runs ?? []).length > 0;
          const isLeaf = !hasChildren;
          if (isLeaf) {
            elRows.appendChild(emptyTaskRow(task, depth + 1));
            return;
          }

          if (collapsedTasks.has(task.taskId)) return;

          for (const c of task.children ?? []) renderTaskNode(c, depth + 1);
          for (const r of (task.runs ?? []).filter((x) => runMatches(task, x))) {
            elRows.appendChild(runRow(task, r, depth + 1, true));
          }
        }

        if (group) {
          for (const t of data) renderTaskNode(t, 0);
          return;
        }

        const flat = [];
        const collectFlat = (t) => {
          if ((t.runs ?? []).length === 0) {
            flat.push({ kind: "task", task: t });
          } else {
            for (const r of t.runs ?? []) flat.push({ kind: "run", task: t, run: r });
          }
          for (const c of t.children ?? []) collectFlat(c);
        };
        for (const t of data) collectFlat(t);

        for (const item of flat) {
          if (item.kind === "task") {
            if (q && !taskMatches(item.task)) continue;
            const tr = document.createElement("tr");
            tr.innerHTML = `
              <td class="muted">-</td>
              <td>Task #${item.task.taskId}: ${item.task.taskTitle}</td>
              <td class="muted">open</td>
              <td class="muted">-</td>
              <td class="muted">-</td>
              <td class="muted">-</td>
              <td class="muted">pending</td>
              <td class="muted">0</td>
              <td class="waterfall"><div class="bar"><span style="width:0%"></span></div></td>
            `;
            elRows.appendChild(tr);
            continue;
          }
          if (!runMatches(item.task, item.run)) continue;
          elRows.appendChild(runRow(item.task, item.run, 0, false));
        }
      }

      function runRow(task, run, depth, grouped) {
        const tr = document.createElement("tr");
        tr.dataset.kind = "run";
        tr.dataset.runId = String(run.runId);
        tr.dataset.taskId = String(task.taskId);

        const nameCell = grouped
          ? `${indentPad(depth)}<span class="muted">Run #${run.runId}</span>`
          : `Task #${task.taskId}: ${task.taskTitle} <span class="muted">/ Run #${run.runId}</span>`;
        tr.innerHTML = `
          <td>${badgeStatus(run.status)}</td>
          <td>${nameCell}</td>
          <td>${run.reasons.map((x) => `<span class="chip">${x}</span>`).join(" ")}</td>
          <td><span class="chip">${run.agent}</span></td>
          <td class="muted">${run.started}</td>
          <td class="mono">${run.durationSec}s</td>
          <td>${badgeDoD(run.dod)}</td>
          <td class="mono">${run.violations}</td>
          <td class="waterfall">
            <div class="bar"><span style="width:${Math.max(4, Math.round((run.durationSec / maxDuration) * 100))}%"></span></div>
          </td>
        `;

        tr.addEventListener("click", () => selectRun(task, run, tr));
        return tr;
      }

      const tabs = [
        { id: "Output", label: "Output" },
        { id: "Meta", label: "Meta" },
        { id: "Timing", label: "Timing" },
        { id: "Checks", label: "Checks" },
        { id: "Violations", label: "Violations" },
        { id: "Git", label: "Git/Worktree" },
      ];

      const elTabs = document.getElementById("tabs");
      const elPanel = document.getElementById("panel");
      const elSel = document.getElementById("selLabel");
      const elSha = document.getElementById("selSha");
      let selected = null;
      let activeTab = "Output";

      function renderTabs() {
        elTabs.innerHTML = "";
        for (const t of tabs) {
          const div = document.createElement("div");
          div.className = "tab" + (t.id === activeTab ? " active" : "");
          div.textContent = t.label;
          div.addEventListener("click", () => {
            activeTab = t.id;
            renderTabs();
            renderPanel();
          });
          elTabs.appendChild(div);
        }
      }

      function renderPanel() {
        if (!selected) {
          elPanel.innerHTML = `<div class="muted">行を選択すると詳細が表示される。</div>`;
          return;
        }
        const { task, run } = selected;
        if (activeTab === "Meta") {
          elPanel.innerHTML = `
            <div class="kv">
              <div>task_id</div><div class="mono">${task.taskId}</div>
              <div>run_id</div><div class="mono">${run.runId}</div>
              <div>agent_profile</div><div>${run.agent}</div>
              <div>prompt</div><div class="mono">[prompt saved to run meta]</div>
              <div>scope_snapshot</div><div class="mono">write_scope + defaultExclude</div>
            </div>
          `;
          return;
        }
        if (activeTab === "Timing") {
          elPanel.innerHTML = `
            <div class="kv">
              <div>scope_apply</div><div class="mono">120ms</div>
              <div>runner_exec</div><div class="mono">${Math.max(1, run.durationSec - 2)}s</div>
              <div>post_check</div><div class="mono">1.2s</div>
              <div>dod_checks</div><div class="mono">3.8s</div>
            </div>
          `;
          return;
        }
        if (activeTab === "Checks") {
          elPanel.innerHTML = `
            <div class="kv">
              <div>dod.status</div><div>${badgeDoD(run.dod)}</div>
              <div>checks</div><div class="mono">lint: passed / test: pending</div>
              <div>output_ref</div><div class="mono">checks/run-${run.runId}/lint.log</div>
            </div>
          `;
          return;
        }
        if (activeTab === "Violations") {
          elPanel.innerHTML = `
            <div class="kv">
              <div>count</div><div class="mono">${run.violations}</div>
              <div>pending</div><div class="mono">${run.violations > 0 ? "2" : "0"}</div>
              <div>action</div><div><button class="btn">approve</button> <button class="btn">reject</button></div>
            </div>
          `;
          return;
        }
        if (activeTab === "Git") {
          elPanel.innerHTML = `
            <div class="kv">
              <div>head_sha</div><div class="mono">${run.headSha}</div>
              <div>worktree_dirty</div><div class="mono">${run.status === "running" ? "unknown" : "false"}</div>
              <div>branch</div><div class="mono">agentmine/task-${task.taskId}</div>
              <div>worktree_path</div><div class="mono">~/.agentmine/worktrees/{project_id}/task-${task.taskId}/</div>
            </div>
          `;
          return;
        }

        // Output (default)
        elPanel.innerHTML = `
          <div class="log">
[stdout] running step: analyze…\n
[stdout] changed files: docs/03-details/ui-mvp.md\n
[meta] prompt saved\n
[stderr] (none)\n
          </div>
        `;
      }

      function clearSelection() {
        for (const tr of document.querySelectorAll('tbody tr[data-kind="run"]')) {
          tr.classList.remove("selected");
        }
      }

      function selectRun(task, run, tr) {
        clearSelection();
        tr.classList.add("selected");
        selected = { task, run };
        elSel.textContent = `Task #${task.taskId} / Run #${run.runId}`;
        elSha.textContent = run.headSha;
        renderPanel();
      }

      renderTabs();
      renderPanel();
      render();
      elGroupBy.addEventListener("change", render);
      elSearch.addEventListener("input", render);

      // Drawer
      const drawer = document.getElementById("drawer");
      const drawerBackdrop = document.getElementById("drawerBackdrop");
      const btnNewTask = document.getElementById("btnNewTask");
      const btnCloseDrawer = document.getElementById("btnCloseDrawer");

      function openDrawer() {
        drawerBackdrop.classList.add("open");
        drawer.classList.add("open");
        updateScopePreview();
      }
      function closeDrawer() {
        drawerBackdrop.classList.remove("open");
        drawer.classList.remove("open");
      }

      btnNewTask.addEventListener("click", openDrawer);
      btnCloseDrawer.addEventListener("click", closeDrawer);
      drawerBackdrop.addEventListener("click", closeDrawer);

	      // write_scope（B only）
	      const scopePreview = document.getElementById("scopePreview");

	      function readTreeGlobs(rootId) {
	        const root = document.getElementById(rootId);
	        if (!root) return [];
	        const checked = Array.from(root.querySelectorAll('input[type="checkbox"]:checked'));
        return checked.map((x) => x.dataset.glob).filter(Boolean);
      }

	      function updateScopePreview() {
	        const scopes = Array.from(new Set(readTreeGlobs("tree")));

	        scopePreview.innerHTML = scopes.map((s) => `<span class="chip">${escapeHtml(s)}</span>`).join("");
	      }

      function escapeHtml(s) {
        return s.replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;");
      }

	      const treeRoot = document.getElementById("tree");
	      if (treeRoot) treeRoot.addEventListener("change", updateScopePreview);
	    </script>
	  </body>
	</html>
