<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>AgentMine UI Prototype - Monitor (Run list)</title>
    <link rel="stylesheet" href="./style.css" />
  </head>
  <body>
    <div class="app">
      <div class="topbar">
        <div class="brand">AgentMine</div>
        <div class="pill"><span class="muted">Project</span> <strong>AgentMine</strong></div>
        <div class="pill">
          <span class="muted">SSE</span> <strong id="sseState">connected</strong>
        </div>
        <div class="spacer"></div>
        <a class="btn" href="./monitor-split.html">Monitor B（Split）</a>
        <a class="btn" href="./monitor-graph.html">Monitor C（Graph）</a>
        <a class="btn" href="./settings.html">Settings</a>
        <a class="btn" href="./agents.html">Agent Profiles</a>
      </div>

      <div class="main detailsHidden" id="main">
        <div class="left">
          <div class="section">
            <h2>Monitor A（Outline table）</h2>
            <div class="row">
              <input
                class="search"
                id="search"
                placeholder="検索: task / run / reason / agent_profile"
                autocomplete="off"
              />
              <label class="toggle">
                <input type="checkbox" id="groupByTask" checked />
                Group by task tree（既定）
              </label>
              <button class="btn primary" id="btnNewTask">+ Task</button>
            </div>
            <div class="row" style="margin-top: 8px">
              <span class="pill"><span class="muted">Filter</span> <strong>running</strong></span>
              <span class="pill"
                ><span class="muted">Filter</span> <strong>needs_review</strong></span
              >
              <span class="pill"
                ><span class="muted">Filter</span> <strong>dod_failed</strong></span
              >
              <span class="pill"><span class="muted">Hint</span> <strong>click row</strong></span>
            </div>
            <div style="height: 10px"></div>
            <div class="overviewWrap">
              <div class="overviewHeader">
                <span>Overview（実行の時間分布）</span>
                <span class="mono" id="rangeLabel">-</span>
              </div>
              <svg
                class="overviewSvg"
                id="overview"
                viewBox="0 0 1000 64"
                preserveAspectRatio="none"
              ></svg>
            </div>
          </div>

          <div class="tableWrap">
            <table>
              <thead>
                <tr>
                  <th style="width: 100px">Status</th>
                  <th style="width: 260px">Task</th>
                  <th style="width: 260px">Reasons</th>
                  <th style="width: 160px">Agent</th>
                  <th style="width: 110px">Started</th>
                  <th style="width: 90px">Duration</th>
                  <th style="width: 90px">DoD</th>
                  <th style="width: 90px">Violations</th>
                  <th class="waterfall">
                    Timeline
                    <div class="wfTicks" id="wfTicks"></div>
                  </th>
                </tr>
              </thead>
              <tbody id="rows"></tbody>
            </table>
          </div>
        </div>

        <div class="right">
          <div class="section">
            <h2>Details</h2>
            <div class="row">
              <span class="pill"
                ><span class="muted">Selected</span> <strong id="selLabel">none</strong></span
              >
              <span class="pill"
                ><span class="muted">head_sha</span>
                <strong class="mono" id="selSha">-</strong></span
              >
              <div class="spacer"></div>
              <button class="btn" id="btnHideDetails">Hide</button>
            </div>
          </div>

          <div class="tabs" id="tabs"></div>
          <div class="panel" id="panel"></div>
        </div>
      </div>
    </div>

    <!-- Task drawer -->
    <div class="drawerBackdrop" id="drawerBackdrop"></div>
    <div class="drawer" id="drawer">
      <div class="drawerHeader">
        <div class="drawerTitle">Create Task</div>
        <div class="spacer"></div>
        <button class="btn" id="btnCloseDrawer">Close</button>
      </div>
      <div class="drawerBody">
        <div class="field">
          <label class="label">Title（必須）</label>
          <input class="input" value="Implement Monitor UI" />
        </div>
        <div class="field">
          <label class="label">Description</label>
          <textarea class="textarea">MonitorをRun一覧（Network風）で実装する。</textarea>
        </div>

        <div class="field">
          <label class="label">write_scope（必須）</label>
          <div class="hint">B（ファイルツリー選択）で確定である。</div>
          <div class="hint">
            個人情報/秘密情報をAIから隠す場合は、write_scopeではなくexcludeを設定する。
            <a href="./settings.html" target="_blank" rel="noopener"
              >Settings（scope.defaultExclude）</a
            >
            を参照。
          </div>
        </div>

        <div class="field">
          <label class="label">Tree selection（B）</label>
          <div class="tree" id="tree">
            <ul>
              <li>
                <label><input type="checkbox" data-glob="apps/web/**" checked /> apps/web/</label>
              </li>
              <li>
                <label><input type="checkbox" data-glob="apps/daemon/**" /> apps/daemon/</label>
              </li>
              <li>
                <label><input type="checkbox" data-glob="packages/**" checked /> packages/</label>
                <ul>
                  <li>
                    <label
                      ><input type="checkbox" data-glob="packages/core/**" /> packages/core/</label
                    >
                  </li>
                  <li>
                    <label><input type="checkbox" data-glob="packages/ui/**" /> packages/ui/</label>
                  </li>
                </ul>
              </li>
              <li>
                <label><input type="checkbox" data-glob="docs/**" checked /> docs/</label>
              </li>
            </ul>
          </div>
          <div class="hint">視覚的で安全。ファイルツリーの取得と表現が必要。</div>
        </div>

        <div class="field">
          <label class="label">プレビュー（最終write_scope）</label>
          <div class="chips" id="scopePreview"></div>
          <div class="hint">
            実装では、この結果をTask.write_scopeとして保存する。run開始時はscope_snapshotに固定される。
          </div>
        </div>
      </div>
      <div class="drawerFooter">
        <button class="btn">Cancel</button>
        <button class="btn primary">Create</button>
      </div>
    </div>

    <script>
      const data = [
        {
          taskId: 10,
          taskTitle: "MVP UI",
          runs: [],
          children: [
            {
              taskId: 12,
              taskTitle: "Monitor UI (Run-first Network)",
              runs: [],
              children: [
                {
                  taskId: 121,
                  taskTitle: "Run table + filters",
                  runs: [
                    {
                      runId: 41,
                      status: "running",
                      reasons: ["merge_pending"],
                      agent: "coder",
                      started: "12:41",
                      durationSec: 132,
                      dod: "pending",
                      violations: 0,
                      headSha: "3f09a1b",
                    },
                    {
                      runId: 40,
                      status: "failed",
                      reasons: ["dod_failed"],
                      agent: "coder",
                      started: "12:10",
                      durationSec: 488,
                      dod: "failed",
                      violations: 0,
                      headSha: "1e2c9d4",
                    },
                  ],
                },
                {
                  taskId: 122,
                  taskTitle: "Details tabs + logs",
                  runs: [
                    {
                      runId: 43,
                      status: "completed",
                      reasons: ["merge_pending"],
                      agent: "coder",
                      started: "12:30",
                      durationSec: 210,
                      dod: "passed",
                      violations: 0,
                      headSha: "4aa91c0",
                    },
                  ],
                },
              ],
            },
            {
              taskId: 15,
              taskTitle: "Settings (exclude) UI",
              runs: [
                {
                  runId: 42,
                  status: "completed",
                  reasons: ["merge_pending"],
                  agent: "writer",
                  started: "12:50",
                  durationSec: 180,
                  dod: "passed",
                  violations: 0,
                  headSha: "7ab1c2d",
                },
              ],
            },
          ],
        },
        {
          taskId: 11,
          taskTitle: "Safety & Quality",
          runs: [],
          children: [
            {
              taskId: 13,
              taskTitle: "Fix scope violation handling",
              runs: [
                {
                  runId: 39,
                  status: "completed",
                  reasons: ["scope_violation_pending"],
                  agent: "generalist",
                  started: "11:22",
                  durationSec: 301,
                  dod: "passed",
                  violations: 2,
                  headSha: "9ad0b2c",
                },
              ],
            },
            {
              taskId: 14,
              taskTitle: "Define DoD checks",
              runs: [],
            },
          ],
        },
      ];

      const elRows = document.getElementById("rows");
      const elGroupBy = document.getElementById("groupByTask");
      const elSearch = document.getElementById("search");
      const elOverview = document.getElementById("overview");
      const elRangeLabel = document.getElementById("rangeLabel");
      const elWfTicks = document.getElementById("wfTicks");
      const elMain = document.getElementById("main");
      const btnHideDetails = document.getElementById("btnHideDetails");

      const collapsedTasks = new Set();

      function parseHHMMToDaySec(hhmm) {
        const [hh, mm] = String(hhmm ?? "00:00")
          .split(":")
          .map((x) => Number(x));
        return (hh || 0) * 3600 + (mm || 0) * 60;
      }

      function walkTasks(tasks, fn) {
        for (const t of tasks) {
          fn(t);
          for (const c of t.children ?? []) walkTasks([c], fn);
        }
      }

      function collectAllRuns(tasks) {
        const runs = [];
        walkTasks(tasks, (t) => runs.push(...(t.runs ?? [])));
        return runs;
      }

      const runsAll = collectAllRuns(data);
      const minAbsStart = Math.min(...runsAll.map((r) => parseHHMMToDaySec(r.started)), 0);
      const baseTimeSec = Math.floor(minAbsStart / 3600) * 3600;
      for (const r of runsAll) r.startedSec = parseHHMMToDaySec(r.started) - baseTimeSec;

      const minStart = Math.min(...runsAll.map((r) => r.startedSec), 0);
      const maxEnd = Math.max(...runsAll.map((r) => r.startedSec + r.durationSec), 1);
      const windowStart = Math.floor(minStart - 60);
      const windowEnd = Math.ceil(maxEnd + 60);
      const windowSpan = Math.max(1, windowEnd - windowStart);

      function fmtTime(sec) {
        const abs = baseTimeSec + sec;
        const hh = Math.floor(abs / 3600);
        const mm = Math.floor((abs % 3600) / 60);
        return `${String(hh).padStart(2, "0")}:${String(mm).padStart(2, "0")}`;
      }

      function pct(sec) {
        return ((sec - windowStart) / windowSpan) * 100;
      }

      function indentPad(depth) {
        return `<span style="display:inline-block;width:${depth * 14}px"></span>`;
      }

      function countRuns(task) {
        let n = (task.runs ?? []).length;
        for (const c of task.children ?? []) n += countRuns(c);
        return n;
      }

      function countSubtasks(task) {
        let n = 0;
        for (const c of task.children ?? []) n += 1 + countSubtasks(c);
        return n;
      }

      function badgeStatus(status) {
        if (status === "running") return '<span class="badge warn">running</span>';
        if (status === "failed") return '<span class="badge danger">failed</span>';
        if (status === "completed") return '<span class="badge ok">completed</span>';
        return `<span class="badge">${status}</span>`;
      }

      function badgeDoD(dod) {
        if (dod === "passed") return '<span class="badge ok">passed</span>';
        if (dod === "failed") return '<span class="badge danger">failed</span>';
        return '<span class="badge warn">pending</span>';
      }

      function renderOverview() {
        if (!elOverview) return;
        const height = 64;
        const width = 1000;
        const buckets = 220;
        const bucketSec = windowSpan / buckets;

        const series = [];
        let maxActive = 1;
        for (let i = 0; i < buckets; i++) {
          const tt = windowStart + bucketSec * (i + 0.5);
          const c = { running: 0, failed: 0, completed: 0, other: 0, total: 0 };
          for (const r of runsAll) {
            if (!(r.startedSec <= tt && tt < r.startedSec + r.durationSec)) continue;
            if (r.status === "running") c.running++;
            else if (r.status === "failed") c.failed++;
            else if (r.status === "completed") c.completed++;
            else c.other++;
          }
          c.total = c.running + c.failed + c.completed + c.other;
          maxActive = Math.max(maxActive, c.total);
          series.push(c);
        }

        const grid = [];
        for (const p of [0, 0.25, 0.5, 0.75, 1]) {
          const x = (width * p).toFixed(1);
          grid.push(
            `<line x1="${x}" y1="0" x2="${x}" y2="${height}" stroke="rgba(255,255,255,0.06)" stroke-width="1" />`
          );
        }

        const bars = [];
        const bw = width / buckets;
        const hScale = (height - 6) / maxActive;
        const seg = (x, y, w, h, fill) =>
          `<rect x="${x.toFixed(1)}" y="${y.toFixed(1)}" width="${w.toFixed(1)}" height="${h.toFixed(
            1
          )}" rx="0" ry="0" fill="${fill}" />`;

        for (let i = 0; i < buckets; i++) {
          const c = series[i];
          if (c.total === 0) continue;
          const x = i * bw;
          const w = bw + 0.6;
          let y = height;
          const stack = [
            ["failed", "rgba(241, 76, 76, 0.75)"],
            ["running", "rgba(204, 167, 0, 0.85)"],
            ["completed", "rgba(137, 209, 133, 0.70)"],
            ["other", "rgba(14, 99, 156, 0.70)"],
          ];
          for (const [k, fill] of stack) {
            const n = c[k];
            if (!n) continue;
            const hh = Math.max(1, n * hScale);
            y -= hh;
            bars.push(seg(x, y, w, hh, fill));
          }
        }

        elOverview.innerHTML = [...grid, ...bars].join("");
        if (elRangeLabel)
          elRangeLabel.textContent = `${fmtTime(windowStart)} - ${fmtTime(windowEnd)}`;
        if (elWfTicks) {
          const ticks = [];
          for (const p of [0, 0.25, 0.5, 0.75, 1]) {
            const sec = windowStart + windowSpan * p;
            ticks.push(`<span>${fmtTime(sec)}</span>`);
          }
          elWfTicks.innerHTML = ticks.join("");
        }
      }

      function render() {
        const q = elSearch.value.trim().toLowerCase();
        const group = elGroupBy.checked;
        elRows.innerHTML = "";

        const matches = (text) => text.toLowerCase().includes(q);
        const taskMatches = (t) => {
          if (!q) return true;
          return matches(t.taskTitle) || matches(String(t.taskId));
        };
        const runMatches = (t, r) => {
          if (!q) return true;
          return (
            matches(String(r.runId)) ||
            matches(r.status) ||
            matches(r.agent) ||
            (r.reasons ?? []).some((x) => matches(x)) ||
            matches(r.dod) ||
            matches(r.headSha) ||
            taskMatches(t)
          );
        };

        const nodeMatches = (t) => {
          if (!q) return true;
          if (taskMatches(t)) return true;
          for (const r of t.runs ?? []) if (runMatches(t, r)) return true;
          for (const c of t.children ?? []) if (nodeMatches(c)) return true;
          return false;
        };

        function taskGroupRow(task, depth) {
          const hasChildren = (task.children ?? []).length > 0 || (task.runs ?? []).length > 0;
          const isLeaf = !hasChildren;
          const isCollapsed = collapsedTasks.has(task.taskId);
          const twisty = isLeaf ? "•" : isCollapsed ? "▸" : "▾";
          const runCount = countRuns(task);
          const subtaskCount = countSubtasks(task);

          const trG = document.createElement("tr");
          trG.className = "groupRow";
          trG.dataset.kind = "task";
          trG.dataset.taskId = String(task.taskId);
          trG.innerHTML = `<td colspan="9">${indentPad(depth)}<span class="twisty">${twisty}</span> Task #${
            task.taskId
          }: ${task.taskTitle} <span class="muted">(${runCount} runs${
            subtaskCount > 0 ? `, ${subtaskCount} subtasks` : ""
          })</span></td>`;

          if (!isLeaf) {
            trG.addEventListener("click", () => {
              if (collapsedTasks.has(task.taskId)) collapsedTasks.delete(task.taskId);
              else collapsedTasks.add(task.taskId);
              render();
            });
          }

          return trG;
        }

        function emptyTaskRow(task, depth) {
          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td class="muted">-</td>
            <td>${indentPad(depth)}<span class="muted">(no runs)</span></td>
            <td class="muted">open</td>
            <td class="muted">-</td>
            <td class="muted">-</td>
            <td class="muted">-</td>
            <td class="muted">pending</td>
            <td class="muted">0</td>
            <td><div class="wf"></div></td>
          `;
          return tr;
        }

        function renderTaskNode(task, depth) {
          if (!nodeMatches(task)) return;

          elRows.appendChild(taskGroupRow(task, depth));

          const hasChildren = (task.children ?? []).length > 0 || (task.runs ?? []).length > 0;
          const isLeaf = !hasChildren;
          if (isLeaf) {
            elRows.appendChild(emptyTaskRow(task, depth + 1));
            return;
          }

          if (collapsedTasks.has(task.taskId)) return;

          for (const c of task.children ?? []) renderTaskNode(c, depth + 1);
          for (const r of (task.runs ?? []).filter((x) => runMatches(task, x))) {
            elRows.appendChild(runRow(task, r, depth + 1, true));
          }
        }

        if (group) {
          for (const t of data) renderTaskNode(t, 0);
          return;
        }

        const flat = [];
        const collectFlat = (t) => {
          if ((t.runs ?? []).length === 0) {
            flat.push({ kind: "task", task: t });
          } else {
            for (const r of t.runs ?? []) flat.push({ kind: "run", task: t, run: r });
          }
          for (const c of t.children ?? []) collectFlat(c);
        };
        for (const t of data) collectFlat(t);

        for (const item of flat) {
          if (item.kind === "task") {
            if (q && !taskMatches(item.task)) continue;
            const tr = document.createElement("tr");
            tr.innerHTML = `
              <td class="muted">-</td>
              <td>Task #${item.task.taskId}: ${item.task.taskTitle}</td>
              <td class="muted">open</td>
              <td class="muted">-</td>
              <td class="muted">-</td>
              <td class="muted">-</td>
              <td class="muted">pending</td>
              <td class="muted">0</td>
              <td><div class="wf"></div></td>
            `;
            elRows.appendChild(tr);
            continue;
          }
          if (!runMatches(item.task, item.run)) continue;
          elRows.appendChild(runRow(item.task, item.run, 0, false));
        }
      }

      function runRow(task, run, depth, grouped) {
        const left = pct(run.startedSec);
        const right = pct(run.startedSec + run.durationSec);
        const width = Math.max(0.8, right - left);

        const tr = document.createElement("tr");
        tr.dataset.kind = "run";
        tr.dataset.runId = String(run.runId);
        tr.dataset.taskId = String(task.taskId);

        const nameCell = grouped
          ? `${indentPad(depth)}<span class="muted">Run #${run.runId}</span>`
          : `Task #${task.taskId}: ${task.taskTitle} <span class="muted">/ Run #${run.runId}</span>`;
        tr.innerHTML = `
          <td>${badgeStatus(run.status)}</td>
          <td>${nameCell}</td>
          <td>${run.reasons.map((x) => `<span class="chip">${x}</span>`).join(" ")}</td>
          <td><span class="chip">${run.agent}</span></td>
          <td class="muted">${fmtTime(run.startedSec)}</td>
          <td class="mono">${run.durationSec}s</td>
          <td>${badgeDoD(run.dod)}</td>
          <td class="mono">${run.violations}</td>
          <td>
            <div class="wf" title="${fmtTime(run.startedSec)} + ${run.durationSec}s">
              <div class="wfBar ${run.status}" style="left:${Math.max(0, left).toFixed(
                2
              )}%; width:${width.toFixed(2)}%"></div>
            </div>
          </td>
        `;

        tr.addEventListener("click", () => selectRun(task, run, tr));
        return tr;
      }

      const tabs = [
        { id: "Output", label: "Output" },
        { id: "Meta", label: "Meta" },
        { id: "Timing", label: "Timing" },
        { id: "Checks", label: "Checks" },
        { id: "Violations", label: "Violations" },
        { id: "Git", label: "Git/Worktree" },
      ];

      const elTabs = document.getElementById("tabs");
      const elPanel = document.getElementById("panel");
      const elSel = document.getElementById("selLabel");
      const elSha = document.getElementById("selSha");
      let selected = null;
      let activeTab = "Output";

      function renderTabs() {
        elTabs.innerHTML = "";
        for (const t of tabs) {
          const div = document.createElement("div");
          div.className = "tab" + (t.id === activeTab ? " active" : "");
          div.textContent = t.label;
          div.addEventListener("click", () => {
            activeTab = t.id;
            renderTabs();
            renderPanel();
          });
          elTabs.appendChild(div);
        }
      }

      function renderPanel() {
        if (!selected) {
          elPanel.innerHTML = `<div class="muted">行を選択すると詳細が表示される。</div>`;
          return;
        }
        const { task, run } = selected;
        if (activeTab === "Meta") {
          elPanel.innerHTML = `
            <div class="kv">
              <div>task_id</div><div class="mono">${task.taskId}</div>
              <div>run_id</div><div class="mono">${run.runId}</div>
              <div>agent_profile</div><div>${run.agent}</div>
              <div>prompt</div><div class="mono">[prompt saved to run meta]</div>
              <div>scope_snapshot</div><div class="mono">write_scope + defaultExclude</div>
            </div>
          `;
          return;
        }
        if (activeTab === "Timing") {
          elPanel.innerHTML = `
            <div class="kv">
              <div>scope_apply</div><div class="mono">120ms</div>
              <div>runner_exec</div><div class="mono">${Math.max(1, run.durationSec - 2)}s</div>
              <div>post_check</div><div class="mono">1.2s</div>
              <div>dod_checks</div><div class="mono">3.8s</div>
            </div>
          `;
          return;
        }
        if (activeTab === "Checks") {
          elPanel.innerHTML = `
            <div class="kv">
              <div>dod.status</div><div>${badgeDoD(run.dod)}</div>
              <div>checks</div><div class="mono">lint: passed / test: pending</div>
              <div>output_ref</div><div class="mono">checks/run-${run.runId}/lint.log</div>
            </div>
          `;
          return;
        }
        if (activeTab === "Violations") {
          elPanel.innerHTML = `
            <div class="kv">
              <div>count</div><div class="mono">${run.violations}</div>
              <div>pending</div><div class="mono">${run.violations > 0 ? "2" : "0"}</div>
              <div>action</div><div><button class="btn">approve</button> <button class="btn">reject</button></div>
            </div>
          `;
          return;
        }
        if (activeTab === "Git") {
          elPanel.innerHTML = `
            <div class="kv">
              <div>head_sha</div><div class="mono">${run.headSha}</div>
              <div>worktree_dirty</div><div class="mono">${run.status === "running" ? "unknown" : "false"}</div>
              <div>branch</div><div class="mono">agentmine/task-${task.taskId}</div>
              <div>worktree_path</div><div class="mono">~/.agentmine/worktrees/{project_id}/task-${task.taskId}/</div>
            </div>
          `;
          return;
        }

        // Output (default)
        elPanel.innerHTML = `
          <div class="log">
[stdout] running step: analyze…\n
[stdout] changed files: docs/03-details/ui-mvp.md\n
[meta] prompt saved\n
[stderr] (none)\n
          </div>
        `;
      }

      function clearSelection() {
        for (const tr of document.querySelectorAll('tbody tr[data-kind="run"]')) {
          tr.classList.remove("selected");
        }
      }

      function selectRun(task, run, tr) {
        clearSelection();
        tr.classList.add("selected");
        selected = { task, run };
        elSel.textContent = `Task #${task.taskId} / Run #${run.runId}`;
        elSha.textContent = run.headSha;
        if (elMain) elMain.classList.remove("detailsHidden");
        renderPanel();
      }

      renderOverview();
      renderTabs();
      renderPanel();
      render();
      elGroupBy.addEventListener("change", render);
      elSearch.addEventListener("input", render);

      if (btnHideDetails) {
        btnHideDetails.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (elMain) elMain.classList.add("detailsHidden");
        });
      }

      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          if (elMain) elMain.classList.add("detailsHidden");
        }
      });

      // Drawer
      const drawer = document.getElementById("drawer");
      const drawerBackdrop = document.getElementById("drawerBackdrop");
      const btnNewTask = document.getElementById("btnNewTask");
      const btnCloseDrawer = document.getElementById("btnCloseDrawer");

      function openDrawer() {
        drawerBackdrop.classList.add("open");
        drawer.classList.add("open");
        updateScopePreview();
      }
      function closeDrawer() {
        drawerBackdrop.classList.remove("open");
        drawer.classList.remove("open");
      }

      btnNewTask.addEventListener("click", openDrawer);
      btnCloseDrawer.addEventListener("click", closeDrawer);
      drawerBackdrop.addEventListener("click", closeDrawer);

      // write_scope（B only）
      const scopePreview = document.getElementById("scopePreview");

      function readTreeGlobs(rootId) {
        const root = document.getElementById(rootId);
        if (!root) return [];
        const checked = Array.from(root.querySelectorAll('input[type="checkbox"]:checked'));
        return checked.map((x) => x.dataset.glob).filter(Boolean);
      }

      function updateScopePreview() {
        const scopes = Array.from(new Set(readTreeGlobs("tree")));

        scopePreview.innerHTML = scopes
          .map((s) => `<span class="chip">${escapeHtml(s)}</span>`)
          .join("");
      }

      function escapeHtml(s) {
        return s.replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;");
      }

      const treeRoot = document.getElementById("tree");
      if (treeRoot) treeRoot.addEventListener("change", updateScopePreview);
    </script>
  </body>
</html>
